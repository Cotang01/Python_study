"""
Даны два массива чисел. Требуется вывести те элементы первого массива
(в том порядке, в каком они идут в первом массиве),
которых нет во втором массиве.
Пользователь вводит число N - количество элементов в первом массиве,
затем N чисел - элементы массива.
Затем число M - количество элементов во втором массиве.
Затем элементы второго массива
"""
import time

# import random
#
# array_1_len = int(input('Введите количество элементов первого массива: '))
# array_1 = [random.randint(1, 20) for _ in range(array_1_len)]
# array_2_len = int(input('Введите количество элементов второго массива: '))
# array_2 = [random.randint(1, 20) for _ in range(array_2_len)]
# print(array_1)
# print(array_2)
# array_3 = []
# index = 0
#
# for i in array_1:
#     if i in array_2:
#         array_3.append(array_1[index])
#     index += 1
#
# # array_3 = [i for i in array_1 if i in array_2] Второй метод
# print(f'Повторяющиеся элементы: {array_3}')
#
# """
# Дан массив, состоящий из целых чисел.
# Напишите программу, которая в данном массиве определит количество элементов,
# у которых два соседних и, при этом, оба соседних элемента меньше данного
# """
# import random
#
# list_1 = [random.randint(1, 20) for _ in range(10)]
# print(list_1)
# count = 0
# index = 1
#
# for i in range(len(list_1) - 2):
#     if list_1[index-1] < list_1[index] > list_1[index+1]:
#         count += 1
#     index += 1
#
# Второй метод
# for i in range(len(list_1)):
#     if list_1[(i - 1) % len(list_1)] < list_1[i % len(list_1)] > \
#             list_1[(i + 1) % len(list_1)]:
#         count += 1
#
# print(f'Таких элементов {count}')
#
# """
# Дан список чисел. Посчитайте, сколько в нем пар элементов, равных друг другу.
# Считается, что любые два элемента, равные друг другу образуют одну пару,
# которую необходимо посчитать.
# """
#
# list_1_len = int(input('Введите длину списка: '))
# list_1 = [random.randint(1, 100) for _ in range(list_1_len)]
# list_1.sort()
# print(list_1)
# count = 0
# index = 0
#
# for i in range(len(list_1)):
#     while list_1.count(index) > 1:
#         count += 1
#         list_1.remove(index)
#         list_1.remove(index)
#     index += 1
#
# print(f'Числа, оставшиеся без пары: {list_1}')
# print(f'Количество пар чисел: {count}')

# # Второй и более эффективный метод
# import random
#
# list_1_len = int(input('Введите длину списка: '))
# list_1 = [random.randint(1, 1000) for _ in range(list_1_len)]  #
# # Генерируется список чисел через list comprehension
# count = 0
# dict_1 = {}  # Создаётся пустой словарь
#
# for i in list_1:
#     dict_1[i] = dict_1.get(i, 0) + 1  # Каждый элемент списка вносится в
#     # словарь, а если этот элемент есть в списке, то значение этого элемента
#     # в словаре увеличивается на 1 (изначально значение 0, после первого
#     # цикла значение 1
# print(dict_1)
# for key, value in dict_1.items():
#     count += value // 2  # Проходимся по ключам словаря. Значением каждого
#     # ключа будет считаться количество повторений каждого элемента в списке,
#     # а чтобы вывести пары, надо это значение целочисленно поделить на 2
#     # (чтобы в итоге получилось не дробное значение)
#
# print(f'Количество пар чисел: {count}')

#
# """
# Два различных натуральных числа n и m называются дружественными,
# если сумма делителей числа n (включая 1, но исключая само n) равна числу m и
# наоборот. Например, 220 и 284 – дружественные числа. По данному числу k
# выведите все пары дружественных чисел, каждое из которых не превосходит k.
# Программа получает на вход одно натуральное число k, не превосходящее 10^5.
# Программа должна вывести все пары дружественных чисел, каждое из которых не
# превосходит k. Пары необходимо выводить по одной в строке, разделяя
# пробелами. Каждая пара должна быть выведена только один раз
# (перестановка чисел новую пару не дает).
# """
# start = time.time()
# dict_divisors = {}  # Создаём пустой словарь
#
#
# def divisors(number: int) -> int:
#     list_divisors = []  # Пустой список для делителей
#     for div in range(1, number // 2 + 1):  # Проходимся от 1 до числа // 2 +
#         # 1, потому что делитель не может быть больше половины числа и + 1,
#         # чтобы range включил последний делитель
#         if not number % div:  # Если число делится на делитель без остатка,
#             list_divisors.append(div)  # то мы добавляем его в список
#     return sum(list_divisors)  # Выводим сумму делителей
#
#
# for number in range(10000):  # Проходимся во всем числам до 10000
#     dict_divisors[number] = divisors(number)  # Каждое число будет являться
#     # ключом, а его значением будет результат функции divisors от этого
#     # числа (то есть сумма его делителей)
#
# list_pair = []  # Создаём список, в который будем добавлять кортежи (пары)
#
# for key, value in dict_divisors.items():  # Проходимся по ключам и значениям
#     # в словаре с числами и суммой их делителей
#     if dict_divisors.get(dict_divisors.get(key)) == key and key != value:  #
#         # Проверяем сходство первого значения ключа со вторым ключом,
#         # у которого значение равно первому ключу + ключ не должен быть
#         # равен значению, чтобы не выводились 0: 0, 6: 6 и подобные
#         if (value, key) not in list_pair:  # Если кортежа нет в списке,
#             # то добавляем его, это нужно для того, чтобы не было дубликатов
#             # по типу (220, 284) (284, 220)
#             list_pair.append((key, value))  # Добавляем
#             print((key, value))  # Выводим
#
# finish = time.time()
# print(finish - start)
